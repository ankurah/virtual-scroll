/**
 * Example React component for README documentation
 *
 * This file provides a compile-checked example for the README via liaison transclusion.
 * It demonstrates the core patterns for using MessageScrollManager in React.
 * The actual playwright tests use MessageList.tsx which has additional test machinery.
 */

// liaison id=react-example
import { useEffect, useRef, useState, useCallback, useMemo } from 'react'

// Types from WASM bindings (generated by ankurah-virtual-scroll-derive)
interface MessageView {
  id: () => { toString: () => string }
  text: () => string
}
interface MessageVisibleSet {
  items: MessageView[]
}
interface MessageVisibleSetSignal {
  get: () => MessageVisibleSet
}
interface MessageScrollManager {
  start: () => Promise<void>
  visibleSet: () => MessageVisibleSetSignal
  onScroll: (firstVisible: string, lastVisible: string, scrollingBackward: boolean) => void
}

// These would come from your WASM bindings package
declare function ctx(): unknown
declare const MessageScrollManager: new (
  ctx: unknown,
  predicate: string,
  orderBy: string,
  minRowHeight: number,
  bufferFactor: number,
  viewportHeight: number
) => MessageScrollManager

const VIEWPORT_HEIGHT = 400
const MIN_ROW_HEIGHT = 40

export function ExampleMessageList({ roomId }: { roomId: string }) {
  const containerRef = useRef<HTMLDivElement>(null)
  const lastScrollTop = useRef(0)
  const [items, setItems] = useState<MessageView[]>([])

  // Create scroll manager once per room
  const manager = useMemo(() => {
    return new MessageScrollManager(
      ctx(),
      `room = '${roomId}'`,
      'timestamp DESC',
      MIN_ROW_HEIGHT,
      2.0,
      VIEWPORT_HEIGHT
    )
  }, [roomId])

  // Initialize and sync state on mount
  useEffect(() => {
    manager.start().then(() => {
      const vs = manager.visibleSet().get()
      setItems([...vs.items])
    })
  }, [manager])

  // Find first/last visible items by checking DOM element positions
  const findVisibleItems = useCallback(() => {
    const container = containerRef.current
    if (!container) return null

    const elements = container.querySelectorAll('[data-item-id]')
    let firstId: string | null = null
    let lastId: string | null = null

    elements.forEach(el => {
      const rect = el.getBoundingClientRect()
      const containerRect = container.getBoundingClientRect()
      // Item is visible if it overlaps with container viewport
      if (rect.bottom > containerRect.top && rect.top < containerRect.bottom) {
        const id = el.getAttribute('data-item-id')
        if (id) {
          if (!firstId) firstId = id
          lastId = id
        }
      }
    })

    return firstId && lastId ? { firstId, lastId } : null
  }, [])

  // Handle scroll events - detect direction and notify scroll manager
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    const el = e.currentTarget
    const scrollingBackward = el.scrollTop < lastScrollTop.current
    lastScrollTop.current = el.scrollTop

    const visible = findVisibleItems()
    if (visible) {
      // Pass EntityId strings (not pixel values) to scroll manager
      manager.onScroll(visible.firstId, visible.lastId, scrollingBackward)
      // Sync state after potential window slide
      const vs = manager.visibleSet().get()
      setItems([...vs.items])
    }
  }, [manager, findVisibleItems])

  return (
    <div
      ref={containerRef}
      onScroll={handleScroll}
      style={{ height: VIEWPORT_HEIGHT, overflowY: 'auto' }}
    >
      {items.map(msg => (
        <div key={msg.id().toString()} data-item-id={msg.id().toString()}>
          {msg.text()}
        </div>
      ))}
    </div>
  )
}
// liaison end
